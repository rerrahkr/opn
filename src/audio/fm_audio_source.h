// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2023 Rerrah

#pragma once

#include <JuceHeader.h>
#include <ymfm_opn.h>

#include <algorithm>
#include <atomic>
#include <concepts>
#include <memory>
#include <mutex>
#include <set>
#include <tuple>
#include <utility>
#include <vector>

#include "../ranged_value.h"
#include "keyboard.h"
#include "parameter.h"
#include "register.h"

namespace audio {
/**
 * @brief Concept of functor to change parameter.
 */
template <class T>
concept ParameterChanger = requires(T f, const FmParameters& parameters,
                                    const std::set<std::size_t>& ids) {
  {
    f(parameters, ids)
  } -> std::convertible_to<std::pair<FmParameters, std::vector<Register>>>;
};

/**
 * @brief Audio source class for FM part.
 * @note Note-on and -off is sensitive on MIDI channel, but pitch bend and pitch
 * bend sensitivity is insensitive.
 */
class FmAudioSource : public juce::AudioSource {
 public:
  /**
   * @brief Constructor.
   */
  FmAudioSource();

  /**
   * @brief Destructor.
   */
  ~FmAudioSource() override;

  /**
   * @brief Get synthesis rate of FM part.
   * @return FM synthesis rate.
   */
  double synthesisRate() const;

  /**
   * @brief Prepare audio source to play.
   * @details Reset emulation.
   */
  void prepareToPlay(int samplesPerBlockExpected,
                     double /*sampleRate*/) override;

  /**
   * @brief Release resources.
   */
  void releaseResources() override {}

  /**
   * @brief Fill samples to a buffer in given channel info.
   * @param[in] bufferToFill Channel info which has a buffer to be stored
   * samples.
   */
  void getNextAudioBlock(
      const juce::AudioSourceChannelInfo& bufferToFill) override;

  // [Changes] -----------------------------------------------------------------
  /**
   * @brief Try to reserve pitch bend sensitivity change.
   *
   * @param[in] value A new value of pitch bend sensitivity.
   * @return \c true if change is accepted, otherwise \c false.
   */
  bool tryReservePitchBendSensitivityChange(int value);

  /**
   * @brief Try to reserve parameter change.
   * @param[in] changer Functor to change parameter.
   * @return \c true if change is accepted, otherwise \c false.
   */
  template <ParameterChanger T>
  bool tryReserveParameterChange(const T&& changer) {
    const std::lock_guard guard(mutex_);
    auto&& [newParameters, changes] =
        changer(toneParameterState_, keyboard_.usedAssignIds());

    if (changes.empty()) {
      return false;
    }

    toneParameterState_ = std::move(newParameters);
    reservedChanges_.reserve(reservedChanges_.size() + changes.size());
    std::move(std::begin(changes), std::end(changes),
              std::back_inserter(reservedChanges_));

    return true;
  }

  /**
   * @brief Try to reserve MIDI message after triggering.
   * @param[in] message MIDI message
   * @return \c true if given message was used. If it was discareded, returns
   * \c false.
   */
  bool tryReserveChangeFromMidiMessage(const juce::MidiMessage& message);

  /**
   * @brief Change audio source state by executing reserved MIDI messages and
   * some changes.
   */
  void triggerReservedChanges();

 private:
  /// Emutator.
  std::unique_ptr<ymfm::ym2608> ym2608_;

  /// Emulator interface.
  ymfm::ymfm_interface interface_;

  /// Temporary buffer to store samples generated by the emulator.
  std::vector<ymfm::ym2608::output_data> outputDataBuffer_;

  /// Mutex.
  std::mutex mutex_;

  // [Polyphony Control] -------------------------------------------------------

  /// Manager of note-on and -off.
  Keyboard keyboard_;

  // [Audio State] -------------------------------------------------------------

  /// Current pitch bend.
  int pitchBend_{0};

  /// Semitone range for pitch bend.
  std::atomic_uint8_t pitchBendSensitivity_{2};

  // State of tone parameters.
  audio::FmParameters toneParameterState_;

  /// RPN/NRPN detector.
  juce::MidiRPNDetector rpnDetector_;

  /// Operator mask which should be note-on.
  std::atomic_uint8_t noteOnMask_{0xf0u};

  // [Register Change] ---------------------------------------------------------

  /// Queue of register changes.
  std::vector<Register> reservedChanges_;

  /**
   * @brief Reserve register changes related on note-on event.
   * @param[in] assignment Details of note-on event.
   * @return \c true if the reservation is success, otherwise \c false.
   */
  bool reserveNoteOn(const NoteAssignment& assignment);

  /**
   * @brief Reserve register changes related on note-off event.
   * @param[in] assignment Details of note-off event.
   * @return \c true if the reservation is success, otherwise \c false.
   */
  bool reserveNoteOff(const NoteAssignment& assignment);

  /**
   * @brief Reserve register changes for all note-on notes related on pitch
   * change event.
   * @return \c true if the reservation is success, otherwise \c false.
   */
  bool reservePitchChange();

  /**
   * @brief Reserve register changes for a specific note related on pitch change
   * event.
   * @param[in] assignment Details of note whose pitch should be changed.
   * @return \c true if the reservation is success, otherwise \c false.
   */
  bool reservePitchChange(const NoteAssignment& assignment);

  /**
   * @brief Reserve register changes related to update tone parameters.
   */
  void reserveUpdatingAllToneParameter();

  JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(FmAudioSource)
};
}  // namespace audio
